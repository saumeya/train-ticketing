package bookingservice

import (
	"context"

	"github.com/google/uuid"

	train "github.com/saumeya/train-ticketing/api"
	pb "github.com/saumeya/train-ticketing/api/proto"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// BookingServer represents the gRPC server for handling booking-related requests
// It also holds Reservation and Trainchart data
type BookingServer struct {
	pb.UnimplementedBookingServiceServer
	reservation []*train.Reservation
	trainChart  *[]*train.TrainChart
}

// NewBookingService initializes and returns a new instance of BookingServer.
// It sets up the trainChart field with mock data generated by MockTrainData().
func NewBookingService() *BookingServer {
	return &BookingServer{
		trainChart: MockTrainData(),
	}
}

// BookTicket reserves a ticket for the user
func (s *BookingServer) BookTicket(ctx context.Context, in *pb.BookingRequest) (*pb.BookingResponse, error) {

	// validate request parameters
	if in.GetFrom() == "" || in.GetTo() == "" || in.GetUser() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "Invalid booking request, insufficient parameters provided")
	}

	// get train_id and cost
	train_id, ticket_cost, err := s.getTrainDetails(in.From, in.To)
	if err != nil {
		return nil, status.Errorf(codes.NotFound, "No trains with available seats for given route")
	}

	// allocate a seat number to the user
	seat, err := s.allocateSeat(train_id)
	if err != nil {
		return nil, status.Errorf(codes.NotFound, "Error allocating seats, no available seats")
	}

	// generate a booking ID
	booking_id := uuid.NewString()

	// create reservation entry for in-memory reservation store
	reservation_entry := &train.Reservation{
		BookingID: booking_id,
		TrainID:   train_id,
		From:      in.From,
		To:        in.To,
		Price:     ticket_cost,
		User: pb.User{
			FirstName: in.User.FirstName,
			LastName:  in.User.LastName,
			Email:     in.User.Email,
		},
		SeatNumber: seat,
	}

	// create reservation entry to in-memory reservation store
	s.reservation = append(s.reservation, reservation_entry)

	// return the response
	return &pb.BookingResponse{
		BookingId: booking_id,
		From:      in.From,
		To:        in.To,
		User: &pb.User{
			FirstName: in.User.FirstName,
			LastName:  in.User.LastName,
			Email:     in.User.Email,
		},
		PricePaid:  ticket_cost,
		SeatNumber: seat,
	}, nil

}

// ShowReceipt shows the confirmed receipt of the booked ticket from the user email
// It can be improved to use BookingID when connected to database
func (s *BookingServer) ShowReceipt(ctx context.Context, in *pb.ShowReceiptRequest) (*pb.ShowReceiptResponse, error) {

	// validate request parameters
	if in.GetBookingId() == "" || in.GetUser() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "Invalid request, insufficient parameters provided")
	}

	// check the in-memory reservtion store to find the email of the user requesting receipt
	for _, reservation := range s.reservation {
		if reservation.User.Email == in.User.Email {
			return &pb.ShowReceiptResponse{
				BookingId: reservation.BookingID,
				From:      reservation.From,
				To:        reservation.To,
				User: &pb.User{
					FirstName: reservation.User.FirstName,
					LastName:  reservation.User.LastName,
					Email:     reservation.User.Email,
				},
				PricePaid:  reservation.Price,
				SeatNumber: reservation.SeatNumber,
			}, nil
		}
	}
	return nil, status.Errorf(codes.NotFound, "No receipt found for this user")
}

// RemoveUser cancels the user ticket on request and deallocated the seat
func (s *BookingServer) RemoveUser(ctx context.Context, in *pb.RemoveUserRequest) (*pb.RemoveUserResponse, error) {

	// validate request parameters
	if in.GetBookingId() == "" || in.GetUser() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "Invalid request, insufficient parameters provided")
	}

	// find the requested reservation entry
	for i, reservation := range s.reservation {
		if reservation.User.Email == in.User.Email {

			//remove the reservation from the in-memory store
			s.reservation = append(s.reservation[:i], s.reservation[i+1:]...)

			//deallocate the seat that was assigned to the user
			err := s.deallocateSeat(reservation.TrainID, reservation.SeatNumber)
			if err != nil {
				return nil, status.Errorf(codes.Internal, "Error in cancelling the ticket")
			}
			return &pb.RemoveUserResponse{
				BookingId:  in.BookingId,
				SeatNumber: reservation.SeatNumber,
			}, nil
		}
	}

	return nil, status.Errorf(codes.NotFound, "No reservation found for this user for cancellation")
}

// ModifyUserSeat modifies the seat number allotted to the user to the one requested if it is available
// The user needs to provide the requested seat number
func (s *BookingServer) ModifyUserSeat(ctx context.Context, in *pb.ModifyUserSeatRequest) (*pb.ModifyUserSeatResponse, error) {

	// validate request parameters
	if in.GetBookingId() == "" || in.GetUser() == nil {
		return nil, status.Errorf(codes.InvalidArgument, "Invalid request, insufficient parameters provided")
	}

	// find the requested reservation entry
	for _, reservation := range s.reservation {
		if reservation.User.Email == in.User.Email {
			err := s.modifySeat(reservation.TrainID, reservation.SeatNumber, in.RequestedSeat)
			if err != nil {
				return nil, status.Errorf(codes.Internal, "Error modifying the ticket, requested seat not available")
			}
			oldSeat := reservation.SeatNumber
			reservation.SeatNumber = in.RequestedSeat
			return &pb.ModifyUserSeatResponse{
				BookingId:   in.BookingId,
				SeatNumber:  oldSeat,
				RequestSeat: in.RequestedSeat,
			}, nil
		}
	}

	return nil, status.Errorf(codes.NotFound, "No reservation found for this user for modification")
}

// ViewSeatsBySection returns the User Seat Mapping for a particular section
func (s *BookingServer) ViewSeatsBySection(ctx context.Context, in *pb.ViewSeatsBySectionRequest) (*pb.ViewSeatsBySectionResponse, error) {

	var userSeatsSection []*pb.UserSeatSection
	var trainID string
	for _, reservation := range s.reservation {
		// Check if the reservation matches the train, from, and to criteria
		if reservation.From == in.From && reservation.To == in.To {
			trainID = reservation.TrainID
			// Check for the given section
			if reservation.SeatNumber[0:1] == in.TrainSection[len(in.TrainSection)-1:] {
				// Add the user and seat number to the result
				userSeat := &pb.UserSeatSection{
					User: &pb.User{
						FirstName: reservation.User.FirstName,
						LastName:  reservation.User.LastName,
						Email:     reservation.User.Email,
					},
					SeatNumber: reservation.SeatNumber,
				}
				userSeatsSection = append(userSeatsSection, userSeat)
			}
		}
	}
	if trainID == "" {
		return nil, status.Errorf(codes.NotFound, "No trains found for the given route")
	}
	return &pb.ViewSeatsBySectionResponse{
		TrainId:      trainID,
		From:         in.From,
		To:           in.To,
		TrainSection: in.TrainSection,
		Seats:        userSeatsSection,
	}, nil
}

// ViewTrainChart returns the chart for a particular train
func (s *BookingServer) ViewTrainChart(ctx context.Context, in *pb.ViewTrainChartRequest) (*pb.ViewTrainChartResponse, error) {

	// fetch the train chart response
	trainID, trainChart, err := s.getTrainChart(in.From, in.To)

	if err != nil {
		return nil, status.Errorf(codes.NotFound, "No trains found for the given route")
	}
	return &pb.ViewTrainChartResponse{
		TrainId:  trainID,
		From:     in.From,
		To:       in.To,
		Response: trainChart,
	}, nil
}
